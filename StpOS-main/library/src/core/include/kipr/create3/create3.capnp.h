// Generated by Cap'n Proto compiler, DO NOT EDIT
// source: create3.capnp

#pragma once

#include <capnp/generated-header-support.h>
#include <kj/windows-sanity.h>
#if !CAPNP_LITE
#include <capnp/capability.h>
#endif  // !CAPNP_LITE

#ifndef CAPNP_VERSION
#error "CAPNP_VERSION is not defined, is capnp/generated-header-support.h missing?"
#elif CAPNP_VERSION != 1000000
#error "Version mismatch between generated code and library headers.  You must use the same version of the Cap'n Proto compiler and library."
#endif


CAPNP_BEGIN_HEADER

namespace capnp {
namespace schemas {

CAPNP_DECLARE_SCHEMA(f5cd8158c7145966);
CAPNP_DECLARE_SCHEMA(e0942eeffa5dfe86);
CAPNP_DECLARE_SCHEMA(81a2f49eff0e2639);
CAPNP_DECLARE_SCHEMA(fa38cdaba3aa6689);
CAPNP_DECLARE_SCHEMA(ff968a3a3dc44774);
CAPNP_DECLARE_SCHEMA(a4ceaa458b464805);
CAPNP_DECLARE_SCHEMA(fcca6f2a3ffd7bf2);
CAPNP_DECLARE_SCHEMA(abe1509a00583b9c);
CAPNP_DECLARE_SCHEMA(ec7a7b515cf9e505);
CAPNP_DECLARE_SCHEMA(a72192b8234656f2);
CAPNP_DECLARE_SCHEMA(c21f001a8f0c645a);
CAPNP_DECLARE_SCHEMA(dbb2668ef74e8d23);
CAPNP_DECLARE_SCHEMA(9ef75a19070a50c5);
CAPNP_DECLARE_SCHEMA(aeb1fc415d9384ba);
CAPNP_DECLARE_SCHEMA(dfb08a7ff46ba3d8);
CAPNP_DECLARE_SCHEMA(a73dfe8e1c185e28);
CAPNP_DECLARE_SCHEMA(e7d1d3b5cc8341e3);
CAPNP_DECLARE_SCHEMA(ff6e30e01fdc78b9);
CAPNP_DECLARE_SCHEMA(a33d5e6a5a5ae3fa);
CAPNP_DECLARE_SCHEMA(b5048bb28871507e);
CAPNP_DECLARE_SCHEMA(f05c2f99c5e5c18f);
CAPNP_DECLARE_SCHEMA(adfc80a2260235aa);
CAPNP_DECLARE_SCHEMA(ca459b31165238ea);
CAPNP_DECLARE_SCHEMA(e12d59dc8cd35ea4);
CAPNP_DECLARE_SCHEMA(857f4d75c1bae4a2);
CAPNP_DECLARE_SCHEMA(d57eff2c7a07bfed);
CAPNP_DECLARE_SCHEMA(b38a425023ce9d12);
CAPNP_DECLARE_SCHEMA(db77ef25f586b5fb);
CAPNP_DECLARE_SCHEMA(efd5c4f2b92bb3ca);
CAPNP_DECLARE_SCHEMA(aa44ead80c127988);
CAPNP_DECLARE_SCHEMA(ecfca9b1b87be14a);
CAPNP_DECLARE_SCHEMA(ee434376cd16d8b1);
CAPNP_DECLARE_SCHEMA(9ab70222567975a1);
CAPNP_DECLARE_SCHEMA(ffe94bf7909dd5d5);
CAPNP_DECLARE_SCHEMA(977905c7b6e2b783);
CAPNP_DECLARE_SCHEMA(d50ba9413985532c);
CAPNP_DECLARE_SCHEMA(e7e63eb13e952ecc);
CAPNP_DECLARE_SCHEMA(d6c4f85d25eda72e);

}  // namespace schemas
}  // namespace capnp

namespace kipr {
namespace create3 {

struct Twist {
  Twist() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f5cd8158c7145966, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Duration {
  Duration() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e0942eeffa5dfe86, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct LedColor {
  LedColor() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(81a2f49eff0e2639, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Lightring {
  Lightring() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fa38cdaba3aa6689, 0, 6)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct HazardDetection {
  HazardDetection() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff968a3a3dc44774, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct IrIntensity {
  IrIntensity() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a4ceaa458b464805, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Quaternion {
  Quaternion() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(fcca6f2a3ffd7bf2, 4, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Vector3 {
  Vector3() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(abe1509a00583b9c, 3, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Pose {
  Pose() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ec7a7b515cf9e505, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3 {
  Create3() = delete;

#if !CAPNP_LITE
  class Client;
  class Server;
#endif  // !CAPNP_LITE

  struct IsConnectedParams;
  struct IsConnectedResults;
  struct SetVelocityParams;
  struct SetVelocityResults;
  struct DockParams;
  struct DockResults;
  struct UndockParams;
  struct UndockResults;
  struct DriveDistanceParams;
  struct DriveDistanceResults;
  struct DriveArcParams;
  struct DriveArcResults;
  struct LedAnimationParams;
  struct LedAnimationResults;
  struct RotateParams;
  struct RotateResults;
  struct NavigateToParams;
  struct NavigateToResults;
  struct FollowWallParams;
  struct FollowWallResults;
  struct GetCliffIntensityVectorParams;
  struct GetCliffIntensityVectorResults;
  struct GetHazardDetectionVectorParams;
  struct GetHazardDetectionVectorResults;
  struct GetIrIntensityVectorParams;
  struct GetIrIntensityVectorResults;
  struct GetOdometryParams;
  struct GetOdometryResults;

  #if !CAPNP_LITE
  struct _capnpPrivate {
    CAPNP_DECLARE_INTERFACE_HEADER(a72192b8234656f2)
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
  };
  #endif  // !CAPNP_LITE
};

struct Create3::IsConnectedParams {
  IsConnectedParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(c21f001a8f0c645a, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::IsConnectedResults {
  IsConnectedResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dbb2668ef74e8d23, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::SetVelocityParams {
  SetVelocityParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ef75a19070a50c5, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::SetVelocityResults {
  SetVelocityResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aeb1fc415d9384ba, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::DockParams {
  DockParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(dfb08a7ff46ba3d8, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::DockResults {
  DockResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a73dfe8e1c185e28, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::UndockParams {
  UndockParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e7d1d3b5cc8341e3, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::UndockResults {
  UndockResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ff6e30e01fdc78b9, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::DriveDistanceParams {
  DriveDistanceParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(a33d5e6a5a5ae3fa, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::DriveDistanceResults {
  DriveDistanceResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b5048bb28871507e, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::DriveArcParams {
  DriveArcParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(f05c2f99c5e5c18f, 2, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::DriveArcResults {
  DriveArcResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(adfc80a2260235aa, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::LedAnimationParams {
  LedAnimationParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ca459b31165238ea, 1, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::LedAnimationResults {
  LedAnimationResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e12d59dc8cd35ea4, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::RotateParams {
  RotateParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(857f4d75c1bae4a2, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::RotateResults {
  RotateResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d57eff2c7a07bfed, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::NavigateToParams {
  NavigateToParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(b38a425023ce9d12, 2, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::NavigateToResults {
  NavigateToResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(db77ef25f586b5fb, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::FollowWallParams {
  FollowWallParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(efd5c4f2b92bb3ca, 1, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::FollowWallResults {
  FollowWallResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(aa44ead80c127988, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::GetCliffIntensityVectorParams {
  GetCliffIntensityVectorParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ecfca9b1b87be14a, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::GetCliffIntensityVectorResults {
  GetCliffIntensityVectorResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ee434376cd16d8b1, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::GetHazardDetectionVectorParams {
  GetHazardDetectionVectorParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(9ab70222567975a1, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::GetHazardDetectionVectorResults {
  GetHazardDetectionVectorResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(ffe94bf7909dd5d5, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::GetIrIntensityVectorParams {
  GetIrIntensityVectorParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(977905c7b6e2b783, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::GetIrIntensityVectorResults {
  GetIrIntensityVectorResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d50ba9413985532c, 0, 1)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::GetOdometryParams {
  GetOdometryParams() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(e7e63eb13e952ecc, 0, 0)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

struct Create3::GetOdometryResults {
  GetOdometryResults() = delete;

  class Reader;
  class Builder;
  class Pipeline;

  struct _capnpPrivate {
    CAPNP_DECLARE_STRUCT_HEADER(d6c4f85d25eda72e, 0, 2)
    #if !CAPNP_LITE
    static constexpr ::capnp::_::RawBrandedSchema const* brand() { return &schema->defaultBrand; }
    #endif  // !CAPNP_LITE
  };
};

// =======================================================================================

class Twist::Reader {
public:
  typedef Twist Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getLinearX() const;

  inline double getAngularZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Twist::Builder {
public:
  typedef Twist Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getLinearX();
  inline void setLinearX(double value);

  inline double getAngularZ();
  inline void setAngularZ(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Twist::Pipeline {
public:
  typedef Twist Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Duration::Reader {
public:
  typedef Duration Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int32_t getSeconds() const;

  inline  ::uint32_t getNanoseconds() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Duration::Builder {
public:
  typedef Duration Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int32_t getSeconds();
  inline void setSeconds( ::int32_t value);

  inline  ::uint32_t getNanoseconds();
  inline void setNanoseconds( ::uint32_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Duration::Pipeline {
public:
  typedef Duration Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class LedColor::Reader {
public:
  typedef LedColor Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getR() const;

  inline  ::uint8_t getG() const;

  inline  ::uint8_t getB() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class LedColor::Builder {
public:
  typedef LedColor Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getR();
  inline void setR( ::uint8_t value);

  inline  ::uint8_t getG();
  inline void setG( ::uint8_t value);

  inline  ::uint8_t getB();
  inline void setB( ::uint8_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class LedColor::Pipeline {
public:
  typedef LedColor Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Lightring::Reader {
public:
  typedef Lightring Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasLed0() const;
  inline  ::kipr::create3::LedColor::Reader getLed0() const;

  inline bool hasLed1() const;
  inline  ::kipr::create3::LedColor::Reader getLed1() const;

  inline bool hasLed2() const;
  inline  ::kipr::create3::LedColor::Reader getLed2() const;

  inline bool hasLed3() const;
  inline  ::kipr::create3::LedColor::Reader getLed3() const;

  inline bool hasLed4() const;
  inline  ::kipr::create3::LedColor::Reader getLed4() const;

  inline bool hasLed5() const;
  inline  ::kipr::create3::LedColor::Reader getLed5() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Lightring::Builder {
public:
  typedef Lightring Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasLed0();
  inline  ::kipr::create3::LedColor::Builder getLed0();
  inline void setLed0( ::kipr::create3::LedColor::Reader value);
  inline  ::kipr::create3::LedColor::Builder initLed0();
  inline void adoptLed0(::capnp::Orphan< ::kipr::create3::LedColor>&& value);
  inline ::capnp::Orphan< ::kipr::create3::LedColor> disownLed0();

  inline bool hasLed1();
  inline  ::kipr::create3::LedColor::Builder getLed1();
  inline void setLed1( ::kipr::create3::LedColor::Reader value);
  inline  ::kipr::create3::LedColor::Builder initLed1();
  inline void adoptLed1(::capnp::Orphan< ::kipr::create3::LedColor>&& value);
  inline ::capnp::Orphan< ::kipr::create3::LedColor> disownLed1();

  inline bool hasLed2();
  inline  ::kipr::create3::LedColor::Builder getLed2();
  inline void setLed2( ::kipr::create3::LedColor::Reader value);
  inline  ::kipr::create3::LedColor::Builder initLed2();
  inline void adoptLed2(::capnp::Orphan< ::kipr::create3::LedColor>&& value);
  inline ::capnp::Orphan< ::kipr::create3::LedColor> disownLed2();

  inline bool hasLed3();
  inline  ::kipr::create3::LedColor::Builder getLed3();
  inline void setLed3( ::kipr::create3::LedColor::Reader value);
  inline  ::kipr::create3::LedColor::Builder initLed3();
  inline void adoptLed3(::capnp::Orphan< ::kipr::create3::LedColor>&& value);
  inline ::capnp::Orphan< ::kipr::create3::LedColor> disownLed3();

  inline bool hasLed4();
  inline  ::kipr::create3::LedColor::Builder getLed4();
  inline void setLed4( ::kipr::create3::LedColor::Reader value);
  inline  ::kipr::create3::LedColor::Builder initLed4();
  inline void adoptLed4(::capnp::Orphan< ::kipr::create3::LedColor>&& value);
  inline ::capnp::Orphan< ::kipr::create3::LedColor> disownLed4();

  inline bool hasLed5();
  inline  ::kipr::create3::LedColor::Builder getLed5();
  inline void setLed5( ::kipr::create3::LedColor::Reader value);
  inline  ::kipr::create3::LedColor::Builder initLed5();
  inline void adoptLed5(::capnp::Orphan< ::kipr::create3::LedColor>&& value);
  inline ::capnp::Orphan< ::kipr::create3::LedColor> disownLed5();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Lightring::Pipeline {
public:
  typedef Lightring Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::kipr::create3::LedColor::Pipeline getLed0();
  inline  ::kipr::create3::LedColor::Pipeline getLed1();
  inline  ::kipr::create3::LedColor::Pipeline getLed2();
  inline  ::kipr::create3::LedColor::Pipeline getLed3();
  inline  ::kipr::create3::LedColor::Pipeline getLed4();
  inline  ::kipr::create3::LedColor::Pipeline getLed5();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class HazardDetection::Reader {
public:
  typedef HazardDetection Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType() const;

  inline bool hasFrameId() const;
  inline  ::capnp::Text::Reader getFrameId() const;

  inline double getTimestamp() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class HazardDetection::Builder {
public:
  typedef HazardDetection Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::uint8_t getType();
  inline void setType( ::uint8_t value);

  inline bool hasFrameId();
  inline  ::capnp::Text::Builder getFrameId();
  inline void setFrameId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFrameId(unsigned int size);
  inline void adoptFrameId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFrameId();

  inline double getTimestamp();
  inline void setTimestamp(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class HazardDetection::Pipeline {
public:
  typedef HazardDetection Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class IrIntensity::Reader {
public:
  typedef IrIntensity Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasFrameId() const;
  inline  ::capnp::Text::Reader getFrameId() const;

  inline double getTimestamp() const;

  inline  ::int16_t getIntensity() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class IrIntensity::Builder {
public:
  typedef IrIntensity Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasFrameId();
  inline  ::capnp::Text::Builder getFrameId();
  inline void setFrameId( ::capnp::Text::Reader value);
  inline  ::capnp::Text::Builder initFrameId(unsigned int size);
  inline void adoptFrameId(::capnp::Orphan< ::capnp::Text>&& value);
  inline ::capnp::Orphan< ::capnp::Text> disownFrameId();

  inline double getTimestamp();
  inline void setTimestamp(double value);

  inline  ::int16_t getIntensity();
  inline void setIntensity( ::int16_t value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class IrIntensity::Pipeline {
public:
  typedef IrIntensity Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Quaternion::Reader {
public:
  typedef Quaternion Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

  inline double getZ() const;

  inline double getW() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Quaternion::Builder {
public:
  typedef Quaternion Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

  inline double getZ();
  inline void setZ(double value);

  inline double getW();
  inline void setW(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Quaternion::Pipeline {
public:
  typedef Quaternion Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Vector3::Reader {
public:
  typedef Vector3 Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline double getX() const;

  inline double getY() const;

  inline double getZ() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Vector3::Builder {
public:
  typedef Vector3 Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline double getX();
  inline void setX(double value);

  inline double getY();
  inline void setY(double value);

  inline double getZ();
  inline void setZ(double value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Vector3::Pipeline {
public:
  typedef Vector3 Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Pose::Reader {
public:
  typedef Pose Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPosition() const;
  inline  ::kipr::create3::Vector3::Reader getPosition() const;

  inline bool hasOrientation() const;
  inline  ::kipr::create3::Quaternion::Reader getOrientation() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Pose::Builder {
public:
  typedef Pose Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPosition();
  inline  ::kipr::create3::Vector3::Builder getPosition();
  inline void setPosition( ::kipr::create3::Vector3::Reader value);
  inline  ::kipr::create3::Vector3::Builder initPosition();
  inline void adoptPosition(::capnp::Orphan< ::kipr::create3::Vector3>&& value);
  inline ::capnp::Orphan< ::kipr::create3::Vector3> disownPosition();

  inline bool hasOrientation();
  inline  ::kipr::create3::Quaternion::Builder getOrientation();
  inline void setOrientation( ::kipr::create3::Quaternion::Reader value);
  inline  ::kipr::create3::Quaternion::Builder initOrientation();
  inline void adoptOrientation(::capnp::Orphan< ::kipr::create3::Quaternion>&& value);
  inline ::capnp::Orphan< ::kipr::create3::Quaternion> disownOrientation();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Pose::Pipeline {
public:
  typedef Pose Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::kipr::create3::Vector3::Pipeline getPosition();
  inline  ::kipr::create3::Quaternion::Pipeline getOrientation();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

#if !CAPNP_LITE
class Create3::Client
    : public virtual ::capnp::Capability::Client {
public:
  typedef Create3 Calls;
  typedef Create3 Reads;

  Client(decltype(nullptr));
  explicit Client(::kj::Own< ::capnp::ClientHook>&& hook);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Server*>()>>
  Client(::kj::Own<_t>&& server);
  template <typename _t, typename = ::kj::EnableIf< ::kj::canConvert<_t*, Client*>()>>
  Client(::kj::Promise<_t>&& promise);
  Client(::kj::Exception&& exception);
  Client(Client&) = default;
  Client(Client&&) = default;
  Client& operator=(Client& other);
  Client& operator=(Client&& other);

  ::capnp::Request< ::kipr::create3::Create3::IsConnectedParams,  ::kipr::create3::Create3::IsConnectedResults> isConnectedRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::SetVelocityParams,  ::kipr::create3::Create3::SetVelocityResults> setVelocityRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::DockParams,  ::kipr::create3::Create3::DockResults> dockRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::UndockParams,  ::kipr::create3::Create3::UndockResults> undockRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::DriveDistanceParams,  ::kipr::create3::Create3::DriveDistanceResults> driveDistanceRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::DriveArcParams,  ::kipr::create3::Create3::DriveArcResults> driveArcRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::LedAnimationParams,  ::kipr::create3::Create3::LedAnimationResults> ledAnimationRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::RotateParams,  ::kipr::create3::Create3::RotateResults> rotateRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::NavigateToParams,  ::kipr::create3::Create3::NavigateToResults> navigateToRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::FollowWallParams,  ::kipr::create3::Create3::FollowWallResults> followWallRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::GetCliffIntensityVectorParams,  ::kipr::create3::Create3::GetCliffIntensityVectorResults> getCliffIntensityVectorRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::GetHazardDetectionVectorParams,  ::kipr::create3::Create3::GetHazardDetectionVectorResults> getHazardDetectionVectorRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::GetIrIntensityVectorParams,  ::kipr::create3::Create3::GetIrIntensityVectorResults> getIrIntensityVectorRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);
  ::capnp::Request< ::kipr::create3::Create3::GetOdometryParams,  ::kipr::create3::Create3::GetOdometryResults> getOdometryRequest(
      ::kj::Maybe< ::capnp::MessageSize> sizeHint = nullptr);

protected:
  Client() = default;
};

class Create3::Server
    : public virtual ::capnp::Capability::Server {
public:
  typedef Create3 Serves;

  ::capnp::Capability::Server::DispatchCallResult dispatchCall(
      uint64_t interfaceId, uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context)
      override;

protected:
  typedef  ::kipr::create3::Create3::IsConnectedParams IsConnectedParams;
  typedef  ::kipr::create3::Create3::IsConnectedResults IsConnectedResults;
  typedef ::capnp::CallContext<IsConnectedParams, IsConnectedResults> IsConnectedContext;
  virtual ::kj::Promise<void> isConnected(IsConnectedContext context);
  typedef  ::kipr::create3::Create3::SetVelocityParams SetVelocityParams;
  typedef  ::kipr::create3::Create3::SetVelocityResults SetVelocityResults;
  typedef ::capnp::CallContext<SetVelocityParams, SetVelocityResults> SetVelocityContext;
  virtual ::kj::Promise<void> setVelocity(SetVelocityContext context);
  typedef  ::kipr::create3::Create3::DockParams DockParams;
  typedef  ::kipr::create3::Create3::DockResults DockResults;
  typedef ::capnp::CallContext<DockParams, DockResults> DockContext;
  virtual ::kj::Promise<void> dock(DockContext context);
  typedef  ::kipr::create3::Create3::UndockParams UndockParams;
  typedef  ::kipr::create3::Create3::UndockResults UndockResults;
  typedef ::capnp::CallContext<UndockParams, UndockResults> UndockContext;
  virtual ::kj::Promise<void> undock(UndockContext context);
  typedef  ::kipr::create3::Create3::DriveDistanceParams DriveDistanceParams;
  typedef  ::kipr::create3::Create3::DriveDistanceResults DriveDistanceResults;
  typedef ::capnp::CallContext<DriveDistanceParams, DriveDistanceResults> DriveDistanceContext;
  virtual ::kj::Promise<void> driveDistance(DriveDistanceContext context);
  typedef  ::kipr::create3::Create3::DriveArcParams DriveArcParams;
  typedef  ::kipr::create3::Create3::DriveArcResults DriveArcResults;
  typedef ::capnp::CallContext<DriveArcParams, DriveArcResults> DriveArcContext;
  virtual ::kj::Promise<void> driveArc(DriveArcContext context);
  typedef  ::kipr::create3::Create3::LedAnimationParams LedAnimationParams;
  typedef  ::kipr::create3::Create3::LedAnimationResults LedAnimationResults;
  typedef ::capnp::CallContext<LedAnimationParams, LedAnimationResults> LedAnimationContext;
  virtual ::kj::Promise<void> ledAnimation(LedAnimationContext context);
  typedef  ::kipr::create3::Create3::RotateParams RotateParams;
  typedef  ::kipr::create3::Create3::RotateResults RotateResults;
  typedef ::capnp::CallContext<RotateParams, RotateResults> RotateContext;
  virtual ::kj::Promise<void> rotate(RotateContext context);
  typedef  ::kipr::create3::Create3::NavigateToParams NavigateToParams;
  typedef  ::kipr::create3::Create3::NavigateToResults NavigateToResults;
  typedef ::capnp::CallContext<NavigateToParams, NavigateToResults> NavigateToContext;
  virtual ::kj::Promise<void> navigateTo(NavigateToContext context);
  typedef  ::kipr::create3::Create3::FollowWallParams FollowWallParams;
  typedef  ::kipr::create3::Create3::FollowWallResults FollowWallResults;
  typedef ::capnp::CallContext<FollowWallParams, FollowWallResults> FollowWallContext;
  virtual ::kj::Promise<void> followWall(FollowWallContext context);
  typedef  ::kipr::create3::Create3::GetCliffIntensityVectorParams GetCliffIntensityVectorParams;
  typedef  ::kipr::create3::Create3::GetCliffIntensityVectorResults GetCliffIntensityVectorResults;
  typedef ::capnp::CallContext<GetCliffIntensityVectorParams, GetCliffIntensityVectorResults> GetCliffIntensityVectorContext;
  virtual ::kj::Promise<void> getCliffIntensityVector(GetCliffIntensityVectorContext context);
  typedef  ::kipr::create3::Create3::GetHazardDetectionVectorParams GetHazardDetectionVectorParams;
  typedef  ::kipr::create3::Create3::GetHazardDetectionVectorResults GetHazardDetectionVectorResults;
  typedef ::capnp::CallContext<GetHazardDetectionVectorParams, GetHazardDetectionVectorResults> GetHazardDetectionVectorContext;
  virtual ::kj::Promise<void> getHazardDetectionVector(GetHazardDetectionVectorContext context);
  typedef  ::kipr::create3::Create3::GetIrIntensityVectorParams GetIrIntensityVectorParams;
  typedef  ::kipr::create3::Create3::GetIrIntensityVectorResults GetIrIntensityVectorResults;
  typedef ::capnp::CallContext<GetIrIntensityVectorParams, GetIrIntensityVectorResults> GetIrIntensityVectorContext;
  virtual ::kj::Promise<void> getIrIntensityVector(GetIrIntensityVectorContext context);
  typedef  ::kipr::create3::Create3::GetOdometryParams GetOdometryParams;
  typedef  ::kipr::create3::Create3::GetOdometryResults GetOdometryResults;
  typedef ::capnp::CallContext<GetOdometryParams, GetOdometryResults> GetOdometryContext;
  virtual ::kj::Promise<void> getOdometry(GetOdometryContext context);

  inline  ::kipr::create3::Create3::Client thisCap() {
    return ::capnp::Capability::Server::thisCap()
        .template castAs< ::kipr::create3::Create3>();
  }

  ::capnp::Capability::Server::DispatchCallResult dispatchCallInternal(
      uint16_t methodId,
      ::capnp::CallContext< ::capnp::AnyPointer, ::capnp::AnyPointer> context);
};
#endif  // !CAPNP_LITE

class Create3::IsConnectedParams::Reader {
public:
  typedef IsConnectedParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::IsConnectedParams::Builder {
public:
  typedef IsConnectedParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::IsConnectedParams::Pipeline {
public:
  typedef IsConnectedParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::IsConnectedResults::Reader {
public:
  typedef IsConnectedResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool getConnected() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::IsConnectedResults::Builder {
public:
  typedef IsConnectedResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool getConnected();
  inline void setConnected(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::IsConnectedResults::Pipeline {
public:
  typedef IsConnectedResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::SetVelocityParams::Reader {
public:
  typedef SetVelocityParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasVelocity() const;
  inline  ::kipr::create3::Twist::Reader getVelocity() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::SetVelocityParams::Builder {
public:
  typedef SetVelocityParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasVelocity();
  inline  ::kipr::create3::Twist::Builder getVelocity();
  inline void setVelocity( ::kipr::create3::Twist::Reader value);
  inline  ::kipr::create3::Twist::Builder initVelocity();
  inline void adoptVelocity(::capnp::Orphan< ::kipr::create3::Twist>&& value);
  inline ::capnp::Orphan< ::kipr::create3::Twist> disownVelocity();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::SetVelocityParams::Pipeline {
public:
  typedef SetVelocityParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::kipr::create3::Twist::Pipeline getVelocity();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::SetVelocityResults::Reader {
public:
  typedef SetVelocityResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::SetVelocityResults::Builder {
public:
  typedef SetVelocityResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::SetVelocityResults::Pipeline {
public:
  typedef SetVelocityResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::DockParams::Reader {
public:
  typedef DockParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::DockParams::Builder {
public:
  typedef DockParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::DockParams::Pipeline {
public:
  typedef DockParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::DockResults::Reader {
public:
  typedef DockResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::DockResults::Builder {
public:
  typedef DockResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::DockResults::Pipeline {
public:
  typedef DockResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::UndockParams::Reader {
public:
  typedef UndockParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::UndockParams::Builder {
public:
  typedef UndockParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::UndockParams::Pipeline {
public:
  typedef UndockParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::UndockResults::Reader {
public:
  typedef UndockResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::UndockResults::Builder {
public:
  typedef UndockResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::UndockResults::Pipeline {
public:
  typedef UndockResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::DriveDistanceParams::Reader {
public:
  typedef DriveDistanceParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getDistance() const;

  inline float getMaxLinearSpeed() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::DriveDistanceParams::Builder {
public:
  typedef DriveDistanceParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getDistance();
  inline void setDistance(float value);

  inline float getMaxLinearSpeed();
  inline void setMaxLinearSpeed(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::DriveDistanceParams::Pipeline {
public:
  typedef DriveDistanceParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::DriveDistanceResults::Reader {
public:
  typedef DriveDistanceResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::DriveDistanceResults::Builder {
public:
  typedef DriveDistanceResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::DriveDistanceResults::Pipeline {
public:
  typedef DriveDistanceResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::DriveArcParams::Reader {
public:
  typedef DriveArcParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int8_t getDirection() const;

  inline float getRadius() const;

  inline float getAngle() const;

  inline float getMaxLinearSpeed() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::DriveArcParams::Builder {
public:
  typedef DriveArcParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int8_t getDirection();
  inline void setDirection( ::int8_t value);

  inline float getRadius();
  inline void setRadius(float value);

  inline float getAngle();
  inline void setAngle(float value);

  inline float getMaxLinearSpeed();
  inline void setMaxLinearSpeed(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::DriveArcParams::Pipeline {
public:
  typedef DriveArcParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::DriveArcResults::Reader {
public:
  typedef DriveArcResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::DriveArcResults::Builder {
public:
  typedef DriveArcResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::DriveArcResults::Pipeline {
public:
  typedef DriveArcResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::LedAnimationParams::Reader {
public:
  typedef LedAnimationParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int8_t getAnimationType() const;

  inline bool hasLightring() const;
  inline  ::kipr::create3::Lightring::Reader getLightring() const;

  inline bool hasDuration() const;
  inline  ::kipr::create3::Duration::Reader getDuration() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::LedAnimationParams::Builder {
public:
  typedef LedAnimationParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int8_t getAnimationType();
  inline void setAnimationType( ::int8_t value);

  inline bool hasLightring();
  inline  ::kipr::create3::Lightring::Builder getLightring();
  inline void setLightring( ::kipr::create3::Lightring::Reader value);
  inline  ::kipr::create3::Lightring::Builder initLightring();
  inline void adoptLightring(::capnp::Orphan< ::kipr::create3::Lightring>&& value);
  inline ::capnp::Orphan< ::kipr::create3::Lightring> disownLightring();

  inline bool hasDuration();
  inline  ::kipr::create3::Duration::Builder getDuration();
  inline void setDuration( ::kipr::create3::Duration::Reader value);
  inline  ::kipr::create3::Duration::Builder initDuration();
  inline void adoptDuration(::capnp::Orphan< ::kipr::create3::Duration>&& value);
  inline ::capnp::Orphan< ::kipr::create3::Duration> disownDuration();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::LedAnimationParams::Pipeline {
public:
  typedef LedAnimationParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::kipr::create3::Lightring::Pipeline getLightring();
  inline  ::kipr::create3::Duration::Pipeline getDuration();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::LedAnimationResults::Reader {
public:
  typedef LedAnimationResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::LedAnimationResults::Builder {
public:
  typedef LedAnimationResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::LedAnimationResults::Pipeline {
public:
  typedef LedAnimationResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::RotateParams::Reader {
public:
  typedef RotateParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline float getAngle() const;

  inline float getMaxAngularSpeed() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::RotateParams::Builder {
public:
  typedef RotateParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline float getAngle();
  inline void setAngle(float value);

  inline float getMaxAngularSpeed();
  inline void setMaxAngularSpeed(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::RotateParams::Pipeline {
public:
  typedef RotateParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::RotateResults::Reader {
public:
  typedef RotateResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::RotateResults::Builder {
public:
  typedef RotateResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::RotateResults::Pipeline {
public:
  typedef RotateResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::NavigateToParams::Reader {
public:
  typedef NavigateToParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPose() const;
  inline  ::kipr::create3::Pose::Reader getPose() const;

  inline float getMaxLinearSpeed() const;

  inline float getMaxAngularSpeed() const;

  inline bool getAchieveGoalHeading() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::NavigateToParams::Builder {
public:
  typedef NavigateToParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPose();
  inline  ::kipr::create3::Pose::Builder getPose();
  inline void setPose( ::kipr::create3::Pose::Reader value);
  inline  ::kipr::create3::Pose::Builder initPose();
  inline void adoptPose(::capnp::Orphan< ::kipr::create3::Pose>&& value);
  inline ::capnp::Orphan< ::kipr::create3::Pose> disownPose();

  inline float getMaxLinearSpeed();
  inline void setMaxLinearSpeed(float value);

  inline float getMaxAngularSpeed();
  inline void setMaxAngularSpeed(float value);

  inline bool getAchieveGoalHeading();
  inline void setAchieveGoalHeading(bool value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::NavigateToParams::Pipeline {
public:
  typedef NavigateToParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::kipr::create3::Pose::Pipeline getPose();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::NavigateToResults::Reader {
public:
  typedef NavigateToResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::NavigateToResults::Builder {
public:
  typedef NavigateToResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::NavigateToResults::Pipeline {
public:
  typedef NavigateToResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::FollowWallParams::Reader {
public:
  typedef FollowWallParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline  ::int8_t getFollow() const;

  inline float getMaxSeconds() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::FollowWallParams::Builder {
public:
  typedef FollowWallParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline  ::int8_t getFollow();
  inline void setFollow( ::int8_t value);

  inline float getMaxSeconds();
  inline void setMaxSeconds(float value);

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::FollowWallParams::Pipeline {
public:
  typedef FollowWallParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::FollowWallResults::Reader {
public:
  typedef FollowWallResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::FollowWallResults::Builder {
public:
  typedef FollowWallResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::FollowWallResults::Pipeline {
public:
  typedef FollowWallResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::GetCliffIntensityVectorParams::Reader {
public:
  typedef GetCliffIntensityVectorParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::GetCliffIntensityVectorParams::Builder {
public:
  typedef GetCliffIntensityVectorParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::GetCliffIntensityVectorParams::Pipeline {
public:
  typedef GetCliffIntensityVectorParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::GetCliffIntensityVectorResults::Reader {
public:
  typedef GetCliffIntensityVectorResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasCliffIntensityVector() const;
  inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Reader getCliffIntensityVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::GetCliffIntensityVectorResults::Builder {
public:
  typedef GetCliffIntensityVectorResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasCliffIntensityVector();
  inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Builder getCliffIntensityVector();
  inline void setCliffIntensityVector( ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Builder initCliffIntensityVector(unsigned int size);
  inline void adoptCliffIntensityVector(::capnp::Orphan< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>> disownCliffIntensityVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::GetCliffIntensityVectorResults::Pipeline {
public:
  typedef GetCliffIntensityVectorResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::GetHazardDetectionVectorParams::Reader {
public:
  typedef GetHazardDetectionVectorParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::GetHazardDetectionVectorParams::Builder {
public:
  typedef GetHazardDetectionVectorParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::GetHazardDetectionVectorParams::Pipeline {
public:
  typedef GetHazardDetectionVectorParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::GetHazardDetectionVectorResults::Reader {
public:
  typedef GetHazardDetectionVectorResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasHazardDetectionVector() const;
  inline  ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>::Reader getHazardDetectionVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::GetHazardDetectionVectorResults::Builder {
public:
  typedef GetHazardDetectionVectorResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasHazardDetectionVector();
  inline  ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>::Builder getHazardDetectionVector();
  inline void setHazardDetectionVector( ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>::Builder initHazardDetectionVector(unsigned int size);
  inline void adoptHazardDetectionVector(::capnp::Orphan< ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>> disownHazardDetectionVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::GetHazardDetectionVectorResults::Pipeline {
public:
  typedef GetHazardDetectionVectorResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::GetIrIntensityVectorParams::Reader {
public:
  typedef GetIrIntensityVectorParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::GetIrIntensityVectorParams::Builder {
public:
  typedef GetIrIntensityVectorParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::GetIrIntensityVectorParams::Pipeline {
public:
  typedef GetIrIntensityVectorParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::GetIrIntensityVectorResults::Reader {
public:
  typedef GetIrIntensityVectorResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasIrIntensityVector() const;
  inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Reader getIrIntensityVector() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::GetIrIntensityVectorResults::Builder {
public:
  typedef GetIrIntensityVectorResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasIrIntensityVector();
  inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Builder getIrIntensityVector();
  inline void setIrIntensityVector( ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Reader value);
  inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Builder initIrIntensityVector(unsigned int size);
  inline void adoptIrIntensityVector(::capnp::Orphan< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>&& value);
  inline ::capnp::Orphan< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>> disownIrIntensityVector();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::GetIrIntensityVectorResults::Pipeline {
public:
  typedef GetIrIntensityVectorResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::GetOdometryParams::Reader {
public:
  typedef GetOdometryParams Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::GetOdometryParams::Builder {
public:
  typedef GetOdometryParams Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::GetOdometryParams::Pipeline {
public:
  typedef GetOdometryParams Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

class Create3::GetOdometryResults::Reader {
public:
  typedef GetOdometryResults Reads;

  Reader() = default;
  inline explicit Reader(::capnp::_::StructReader base): _reader(base) {}

  inline ::capnp::MessageSize totalSize() const {
    return _reader.totalSize().asPublic();
  }

#if !CAPNP_LITE
  inline ::kj::StringTree toString() const {
    return ::capnp::_::structString(_reader, *_capnpPrivate::brand());
  }
#endif  // !CAPNP_LITE

  inline bool hasPose() const;
  inline  ::kipr::create3::Pose::Reader getPose() const;

  inline bool hasVelocity() const;
  inline  ::kipr::create3::Twist::Reader getVelocity() const;

private:
  ::capnp::_::StructReader _reader;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::List;
  friend class ::capnp::MessageBuilder;
  friend class ::capnp::Orphanage;
};

class Create3::GetOdometryResults::Builder {
public:
  typedef GetOdometryResults Builds;

  Builder() = delete;  // Deleted to discourage incorrect usage.
                       // You can explicitly initialize to nullptr instead.
  inline Builder(decltype(nullptr)) {}
  inline explicit Builder(::capnp::_::StructBuilder base): _builder(base) {}
  inline operator Reader() const { return Reader(_builder.asReader()); }
  inline Reader asReader() const { return *this; }

  inline ::capnp::MessageSize totalSize() const { return asReader().totalSize(); }
#if !CAPNP_LITE
  inline ::kj::StringTree toString() const { return asReader().toString(); }
#endif  // !CAPNP_LITE

  inline bool hasPose();
  inline  ::kipr::create3::Pose::Builder getPose();
  inline void setPose( ::kipr::create3::Pose::Reader value);
  inline  ::kipr::create3::Pose::Builder initPose();
  inline void adoptPose(::capnp::Orphan< ::kipr::create3::Pose>&& value);
  inline ::capnp::Orphan< ::kipr::create3::Pose> disownPose();

  inline bool hasVelocity();
  inline  ::kipr::create3::Twist::Builder getVelocity();
  inline void setVelocity( ::kipr::create3::Twist::Reader value);
  inline  ::kipr::create3::Twist::Builder initVelocity();
  inline void adoptVelocity(::capnp::Orphan< ::kipr::create3::Twist>&& value);
  inline ::capnp::Orphan< ::kipr::create3::Twist> disownVelocity();

private:
  ::capnp::_::StructBuilder _builder;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
  friend class ::capnp::Orphanage;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::_::PointerHelpers;
};

#if !CAPNP_LITE
class Create3::GetOdometryResults::Pipeline {
public:
  typedef GetOdometryResults Pipelines;

  inline Pipeline(decltype(nullptr)): _typeless(nullptr) {}
  inline explicit Pipeline(::capnp::AnyPointer::Pipeline&& typeless)
      : _typeless(kj::mv(typeless)) {}

  inline  ::kipr::create3::Pose::Pipeline getPose();
  inline  ::kipr::create3::Twist::Pipeline getVelocity();
private:
  ::capnp::AnyPointer::Pipeline _typeless;
  friend class ::capnp::PipelineHook;
  template <typename, ::capnp::Kind>
  friend struct ::capnp::ToDynamic_;
};
#endif  // !CAPNP_LITE

// =======================================================================================

inline double Twist::Reader::getLinearX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Twist::Builder::getLinearX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Twist::Builder::setLinearX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Twist::Reader::getAngularZ() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Twist::Builder::getAngularZ() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Twist::Builder::setAngularZ(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int32_t Duration::Reader::getSeconds() const {
  return _reader.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int32_t Duration::Builder::getSeconds() {
  return _builder.getDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Duration::Builder::setSeconds( ::int32_t value) {
  _builder.setDataField< ::int32_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint32_t Duration::Reader::getNanoseconds() const {
  return _reader.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint32_t Duration::Builder::getNanoseconds() {
  return _builder.getDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Duration::Builder::setNanoseconds( ::uint32_t value) {
  _builder.setDataField< ::uint32_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t LedColor::Reader::getR() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LedColor::Builder::getR() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void LedColor::Builder::setR( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t LedColor::Reader::getG() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LedColor::Builder::getG() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void LedColor::Builder::setG( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::uint8_t LedColor::Reader::getB() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t LedColor::Builder::getB() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void LedColor::Builder::setB( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Lightring::Reader::hasLed0() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Lightring::Builder::hasLed0() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::LedColor::Reader Lightring::Reader::getLed0() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::getLed0() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::LedColor::Pipeline Lightring::Pipeline::getLed0() {
  return  ::kipr::create3::LedColor::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Lightring::Builder::setLed0( ::kipr::create3::LedColor::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::initLed0() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Lightring::Builder::adoptLed0(
    ::capnp::Orphan< ::kipr::create3::LedColor>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::LedColor> Lightring::Builder::disownLed0() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Lightring::Reader::hasLed1() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Lightring::Builder::hasLed1() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::LedColor::Reader Lightring::Reader::getLed1() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::getLed1() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::LedColor::Pipeline Lightring::Pipeline::getLed1() {
  return  ::kipr::create3::LedColor::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Lightring::Builder::setLed1( ::kipr::create3::LedColor::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::initLed1() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Lightring::Builder::adoptLed1(
    ::capnp::Orphan< ::kipr::create3::LedColor>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::LedColor> Lightring::Builder::disownLed1() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline bool Lightring::Reader::hasLed2() const {
  return !_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline bool Lightring::Builder::hasLed2() {
  return !_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::LedColor::Reader Lightring::Reader::getLed2() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_reader.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::getLed2() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::LedColor::Pipeline Lightring::Pipeline::getLed2() {
  return  ::kipr::create3::LedColor::Pipeline(_typeless.getPointerField(2));
}
#endif  // !CAPNP_LITE
inline void Lightring::Builder::setLed2( ::kipr::create3::LedColor::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::set(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::initLed2() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::init(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}
inline void Lightring::Builder::adoptLed2(
    ::capnp::Orphan< ::kipr::create3::LedColor>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::adopt(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::LedColor> Lightring::Builder::disownLed2() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::disown(_builder.getPointerField(
      ::capnp::bounded<2>() * ::capnp::POINTERS));
}

inline bool Lightring::Reader::hasLed3() const {
  return !_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline bool Lightring::Builder::hasLed3() {
  return !_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::LedColor::Reader Lightring::Reader::getLed3() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_reader.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::getLed3() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::LedColor::Pipeline Lightring::Pipeline::getLed3() {
  return  ::kipr::create3::LedColor::Pipeline(_typeless.getPointerField(3));
}
#endif  // !CAPNP_LITE
inline void Lightring::Builder::setLed3( ::kipr::create3::LedColor::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::set(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::initLed3() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::init(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}
inline void Lightring::Builder::adoptLed3(
    ::capnp::Orphan< ::kipr::create3::LedColor>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::adopt(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::LedColor> Lightring::Builder::disownLed3() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::disown(_builder.getPointerField(
      ::capnp::bounded<3>() * ::capnp::POINTERS));
}

inline bool Lightring::Reader::hasLed4() const {
  return !_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline bool Lightring::Builder::hasLed4() {
  return !_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::LedColor::Reader Lightring::Reader::getLed4() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_reader.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::getLed4() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::LedColor::Pipeline Lightring::Pipeline::getLed4() {
  return  ::kipr::create3::LedColor::Pipeline(_typeless.getPointerField(4));
}
#endif  // !CAPNP_LITE
inline void Lightring::Builder::setLed4( ::kipr::create3::LedColor::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::set(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::initLed4() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::init(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}
inline void Lightring::Builder::adoptLed4(
    ::capnp::Orphan< ::kipr::create3::LedColor>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::adopt(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::LedColor> Lightring::Builder::disownLed4() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::disown(_builder.getPointerField(
      ::capnp::bounded<4>() * ::capnp::POINTERS));
}

inline bool Lightring::Reader::hasLed5() const {
  return !_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline bool Lightring::Builder::hasLed5() {
  return !_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::LedColor::Reader Lightring::Reader::getLed5() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_reader.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::getLed5() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::get(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::LedColor::Pipeline Lightring::Pipeline::getLed5() {
  return  ::kipr::create3::LedColor::Pipeline(_typeless.getPointerField(5));
}
#endif  // !CAPNP_LITE
inline void Lightring::Builder::setLed5( ::kipr::create3::LedColor::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::set(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::LedColor::Builder Lightring::Builder::initLed5() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::init(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}
inline void Lightring::Builder::adoptLed5(
    ::capnp::Orphan< ::kipr::create3::LedColor>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::adopt(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::LedColor> Lightring::Builder::disownLed5() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::LedColor>::disown(_builder.getPointerField(
      ::capnp::bounded<5>() * ::capnp::POINTERS));
}

inline  ::uint8_t HazardDetection::Reader::getType() const {
  return _reader.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::uint8_t HazardDetection::Builder::getType() {
  return _builder.getDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void HazardDetection::Builder::setType( ::uint8_t value) {
  _builder.setDataField< ::uint8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool HazardDetection::Reader::hasFrameId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool HazardDetection::Builder::hasFrameId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader HazardDetection::Reader::getFrameId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder HazardDetection::Builder::getFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void HazardDetection::Builder::setFrameId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder HazardDetection::Builder::initFrameId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void HazardDetection::Builder::adoptFrameId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> HazardDetection::Builder::disownFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double HazardDetection::Reader::getTimestamp() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double HazardDetection::Builder::getTimestamp() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void HazardDetection::Builder::setTimestamp(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool IrIntensity::Reader::hasFrameId() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool IrIntensity::Builder::hasFrameId() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::Text::Reader IrIntensity::Reader::getFrameId() const {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::Text::Builder IrIntensity::Builder::getFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void IrIntensity::Builder::setFrameId( ::capnp::Text::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::Text::Builder IrIntensity::Builder::initFrameId(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void IrIntensity::Builder::adoptFrameId(
    ::capnp::Orphan< ::capnp::Text>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::Text>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::Text> IrIntensity::Builder::disownFrameId() {
  return ::capnp::_::PointerHelpers< ::capnp::Text>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline double IrIntensity::Reader::getTimestamp() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double IrIntensity::Builder::getTimestamp() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void IrIntensity::Builder::setTimestamp(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline  ::int16_t IrIntensity::Reader::getIntensity() const {
  return _reader.getDataField< ::int16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}

inline  ::int16_t IrIntensity::Builder::getIntensity() {
  return _builder.getDataField< ::int16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS);
}
inline void IrIntensity::Builder::setIntensity( ::int16_t value) {
  _builder.setDataField< ::int16_t>(
      ::capnp::bounded<4>() * ::capnp::ELEMENTS, value);
}

inline double Quaternion::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Quaternion::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Quaternion::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Quaternion::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Quaternion::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Quaternion::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Quaternion::Reader::getZ() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Quaternion::Builder::getZ() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Quaternion::Builder::setZ(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline double Quaternion::Reader::getW() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline double Quaternion::Builder::getW() {
  return _builder.getDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Quaternion::Builder::setW(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline double Vector3::Reader::getX() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline double Vector3::Builder::getX() {
  return _builder.getDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Vector3::Builder::setX(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline double Vector3::Reader::getY() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline double Vector3::Builder::getY() {
  return _builder.getDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Vector3::Builder::setY(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline double Vector3::Reader::getZ() const {
  return _reader.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline double Vector3::Builder::getZ() {
  return _builder.getDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Vector3::Builder::setZ(double value) {
  _builder.setDataField<double>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline bool Pose::Reader::hasPosition() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Pose::Builder::hasPosition() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::Vector3::Reader Pose::Reader::getPosition() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Vector3>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::Vector3::Builder Pose::Builder::getPosition() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Vector3>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::Vector3::Pipeline Pose::Pipeline::getPosition() {
  return  ::kipr::create3::Vector3::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Pose::Builder::setPosition( ::kipr::create3::Vector3::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Vector3>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::Vector3::Builder Pose::Builder::initPosition() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Vector3>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Pose::Builder::adoptPosition(
    ::capnp::Orphan< ::kipr::create3::Vector3>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Vector3>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::Vector3> Pose::Builder::disownPosition() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Vector3>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Pose::Reader::hasOrientation() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Pose::Builder::hasOrientation() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::Quaternion::Reader Pose::Reader::getOrientation() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Quaternion>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::Quaternion::Builder Pose::Builder::getOrientation() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Quaternion>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::Quaternion::Pipeline Pose::Pipeline::getOrientation() {
  return  ::kipr::create3::Quaternion::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Pose::Builder::setOrientation( ::kipr::create3::Quaternion::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Quaternion>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::Quaternion::Builder Pose::Builder::initOrientation() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Quaternion>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Pose::Builder::adoptOrientation(
    ::capnp::Orphan< ::kipr::create3::Quaternion>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Quaternion>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::Quaternion> Pose::Builder::disownOrientation() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Quaternion>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

#if !CAPNP_LITE
inline Create3::Client::Client(decltype(nullptr))
    : ::capnp::Capability::Client(nullptr) {}
inline Create3::Client::Client(
    ::kj::Own< ::capnp::ClientHook>&& hook)
    : ::capnp::Capability::Client(::kj::mv(hook)) {}
template <typename _t, typename>
inline Create3::Client::Client(::kj::Own<_t>&& server)
    : ::capnp::Capability::Client(::kj::mv(server)) {}
template <typename _t, typename>
inline Create3::Client::Client(::kj::Promise<_t>&& promise)
    : ::capnp::Capability::Client(::kj::mv(promise)) {}
inline Create3::Client::Client(::kj::Exception&& exception)
    : ::capnp::Capability::Client(::kj::mv(exception)) {}
inline  ::kipr::create3::Create3::Client& Create3::Client::operator=(Client& other) {
  ::capnp::Capability::Client::operator=(other);
  return *this;
}
inline  ::kipr::create3::Create3::Client& Create3::Client::operator=(Client&& other) {
  ::capnp::Capability::Client::operator=(kj::mv(other));
  return *this;
}

#endif  // !CAPNP_LITE
inline bool Create3::IsConnectedResults::Reader::getConnected() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline bool Create3::IsConnectedResults::Builder::getConnected() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Create3::IsConnectedResults::Builder::setConnected(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Create3::SetVelocityParams::Reader::hasVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Create3::SetVelocityParams::Builder::hasVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::Twist::Reader Create3::SetVelocityParams::Reader::getVelocity() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::Twist::Builder Create3::SetVelocityParams::Builder::getVelocity() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::Twist::Pipeline Create3::SetVelocityParams::Pipeline::getVelocity() {
  return  ::kipr::create3::Twist::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Create3::SetVelocityParams::Builder::setVelocity( ::kipr::create3::Twist::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::Twist::Builder Create3::SetVelocityParams::Builder::initVelocity() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Create3::SetVelocityParams::Builder::adoptVelocity(
    ::capnp::Orphan< ::kipr::create3::Twist>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::Twist> Create3::SetVelocityParams::Builder::disownVelocity() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float Create3::DriveDistanceParams::Reader::getDistance() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Create3::DriveDistanceParams::Builder::getDistance() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Create3::DriveDistanceParams::Builder::setDistance(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Create3::DriveDistanceParams::Reader::getMaxLinearSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Create3::DriveDistanceParams::Builder::getMaxLinearSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Create3::DriveDistanceParams::Builder::setMaxLinearSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t Create3::DriveArcParams::Reader::getDirection() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int8_t Create3::DriveArcParams::Builder::getDirection() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Create3::DriveArcParams::Builder::setDirection( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Create3::DriveArcParams::Reader::getRadius() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Create3::DriveArcParams::Builder::getRadius() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Create3::DriveArcParams::Builder::setRadius(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline float Create3::DriveArcParams::Reader::getAngle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}

inline float Create3::DriveArcParams::Builder::getAngle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS);
}
inline void Create3::DriveArcParams::Builder::setAngle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<2>() * ::capnp::ELEMENTS, value);
}

inline float Create3::DriveArcParams::Reader::getMaxLinearSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}

inline float Create3::DriveArcParams::Builder::getMaxLinearSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS);
}
inline void Create3::DriveArcParams::Builder::setMaxLinearSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<3>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t Create3::LedAnimationParams::Reader::getAnimationType() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int8_t Create3::LedAnimationParams::Builder::getAnimationType() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Create3::LedAnimationParams::Builder::setAnimationType( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline bool Create3::LedAnimationParams::Reader::hasLightring() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Create3::LedAnimationParams::Builder::hasLightring() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::Lightring::Reader Create3::LedAnimationParams::Reader::getLightring() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Lightring>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::Lightring::Builder Create3::LedAnimationParams::Builder::getLightring() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Lightring>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::Lightring::Pipeline Create3::LedAnimationParams::Pipeline::getLightring() {
  return  ::kipr::create3::Lightring::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Create3::LedAnimationParams::Builder::setLightring( ::kipr::create3::Lightring::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Lightring>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::Lightring::Builder Create3::LedAnimationParams::Builder::initLightring() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Lightring>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Create3::LedAnimationParams::Builder::adoptLightring(
    ::capnp::Orphan< ::kipr::create3::Lightring>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Lightring>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::Lightring> Create3::LedAnimationParams::Builder::disownLightring() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Lightring>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Create3::LedAnimationParams::Reader::hasDuration() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Create3::LedAnimationParams::Builder::hasDuration() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::Duration::Reader Create3::LedAnimationParams::Reader::getDuration() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Duration>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::Duration::Builder Create3::LedAnimationParams::Builder::getDuration() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Duration>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::Duration::Pipeline Create3::LedAnimationParams::Pipeline::getDuration() {
  return  ::kipr::create3::Duration::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Create3::LedAnimationParams::Builder::setDuration( ::kipr::create3::Duration::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Duration>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::Duration::Builder Create3::LedAnimationParams::Builder::initDuration() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Duration>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Create3::LedAnimationParams::Builder::adoptDuration(
    ::capnp::Orphan< ::kipr::create3::Duration>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Duration>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::Duration> Create3::LedAnimationParams::Builder::disownDuration() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Duration>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

inline float Create3::RotateParams::Reader::getAngle() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Create3::RotateParams::Builder::getAngle() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Create3::RotateParams::Builder::setAngle(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Create3::RotateParams::Reader::getMaxAngularSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Create3::RotateParams::Builder::getMaxAngularSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Create3::RotateParams::Builder::setMaxAngularSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Create3::NavigateToParams::Reader::hasPose() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Create3::NavigateToParams::Builder::hasPose() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::Pose::Reader Create3::NavigateToParams::Reader::getPose() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::Pose::Builder Create3::NavigateToParams::Builder::getPose() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::Pose::Pipeline Create3::NavigateToParams::Pipeline::getPose() {
  return  ::kipr::create3::Pose::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Create3::NavigateToParams::Builder::setPose( ::kipr::create3::Pose::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::Pose::Builder Create3::NavigateToParams::Builder::initPose() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Create3::NavigateToParams::Builder::adoptPose(
    ::capnp::Orphan< ::kipr::create3::Pose>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::Pose> Create3::NavigateToParams::Builder::disownPose() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline float Create3::NavigateToParams::Reader::getMaxLinearSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline float Create3::NavigateToParams::Builder::getMaxLinearSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Create3::NavigateToParams::Builder::setMaxLinearSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Create3::NavigateToParams::Reader::getMaxAngularSpeed() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Create3::NavigateToParams::Builder::getMaxAngularSpeed() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Create3::NavigateToParams::Builder::setMaxAngularSpeed(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Create3::NavigateToParams::Reader::getAchieveGoalHeading() const {
  return _reader.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}

inline bool Create3::NavigateToParams::Builder::getAchieveGoalHeading() {
  return _builder.getDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS);
}
inline void Create3::NavigateToParams::Builder::setAchieveGoalHeading(bool value) {
  _builder.setDataField<bool>(
      ::capnp::bounded<64>() * ::capnp::ELEMENTS, value);
}

inline  ::int8_t Create3::FollowWallParams::Reader::getFollow() const {
  return _reader.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}

inline  ::int8_t Create3::FollowWallParams::Builder::getFollow() {
  return _builder.getDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS);
}
inline void Create3::FollowWallParams::Builder::setFollow( ::int8_t value) {
  _builder.setDataField< ::int8_t>(
      ::capnp::bounded<0>() * ::capnp::ELEMENTS, value);
}

inline float Create3::FollowWallParams::Reader::getMaxSeconds() const {
  return _reader.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}

inline float Create3::FollowWallParams::Builder::getMaxSeconds() {
  return _builder.getDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS);
}
inline void Create3::FollowWallParams::Builder::setMaxSeconds(float value) {
  _builder.setDataField<float>(
      ::capnp::bounded<1>() * ::capnp::ELEMENTS, value);
}

inline bool Create3::GetCliffIntensityVectorResults::Reader::hasCliffIntensityVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Create3::GetCliffIntensityVectorResults::Builder::hasCliffIntensityVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Reader Create3::GetCliffIntensityVectorResults::Reader::getCliffIntensityVector() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Builder Create3::GetCliffIntensityVectorResults::Builder::getCliffIntensityVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Create3::GetCliffIntensityVectorResults::Builder::setCliffIntensityVector( ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Builder Create3::GetCliffIntensityVectorResults::Builder::initCliffIntensityVector(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Create3::GetCliffIntensityVectorResults::Builder::adoptCliffIntensityVector(
    ::capnp::Orphan< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>> Create3::GetCliffIntensityVectorResults::Builder::disownCliffIntensityVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Create3::GetHazardDetectionVectorResults::Reader::hasHazardDetectionVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Create3::GetHazardDetectionVectorResults::Builder::hasHazardDetectionVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>::Reader Create3::GetHazardDetectionVectorResults::Reader::getHazardDetectionVector() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>::Builder Create3::GetHazardDetectionVectorResults::Builder::getHazardDetectionVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Create3::GetHazardDetectionVectorResults::Builder::setHazardDetectionVector( ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>::Builder Create3::GetHazardDetectionVectorResults::Builder::initHazardDetectionVector(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Create3::GetHazardDetectionVectorResults::Builder::adoptHazardDetectionVector(
    ::capnp::Orphan< ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>> Create3::GetHazardDetectionVectorResults::Builder::disownHazardDetectionVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::HazardDetection,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Create3::GetIrIntensityVectorResults::Reader::hasIrIntensityVector() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Create3::GetIrIntensityVectorResults::Builder::hasIrIntensityVector() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Reader Create3::GetIrIntensityVectorResults::Reader::getIrIntensityVector() const {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Builder Create3::GetIrIntensityVectorResults::Builder::getIrIntensityVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Create3::GetIrIntensityVectorResults::Builder::setIrIntensityVector( ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Reader value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>::Builder Create3::GetIrIntensityVectorResults::Builder::initIrIntensityVector(unsigned int size) {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), size);
}
inline void Create3::GetIrIntensityVectorResults::Builder::adoptIrIntensityVector(
    ::capnp::Orphan< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>&& value) {
  ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>> Create3::GetIrIntensityVectorResults::Builder::disownIrIntensityVector() {
  return ::capnp::_::PointerHelpers< ::capnp::List< ::kipr::create3::IrIntensity,  ::capnp::Kind::STRUCT>>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Create3::GetOdometryResults::Reader::hasPose() const {
  return !_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline bool Create3::GetOdometryResults::Builder::hasPose() {
  return !_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::Pose::Reader Create3::GetOdometryResults::Reader::getPose() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::get(_reader.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::Pose::Builder Create3::GetOdometryResults::Builder::getPose() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::get(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::Pose::Pipeline Create3::GetOdometryResults::Pipeline::getPose() {
  return  ::kipr::create3::Pose::Pipeline(_typeless.getPointerField(0));
}
#endif  // !CAPNP_LITE
inline void Create3::GetOdometryResults::Builder::setPose( ::kipr::create3::Pose::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::set(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::Pose::Builder Create3::GetOdometryResults::Builder::initPose() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::init(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}
inline void Create3::GetOdometryResults::Builder::adoptPose(
    ::capnp::Orphan< ::kipr::create3::Pose>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::adopt(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::Pose> Create3::GetOdometryResults::Builder::disownPose() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Pose>::disown(_builder.getPointerField(
      ::capnp::bounded<0>() * ::capnp::POINTERS));
}

inline bool Create3::GetOdometryResults::Reader::hasVelocity() const {
  return !_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline bool Create3::GetOdometryResults::Builder::hasVelocity() {
  return !_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS).isNull();
}
inline  ::kipr::create3::Twist::Reader Create3::GetOdometryResults::Reader::getVelocity() const {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::get(_reader.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline  ::kipr::create3::Twist::Builder Create3::GetOdometryResults::Builder::getVelocity() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::get(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
#if !CAPNP_LITE
inline  ::kipr::create3::Twist::Pipeline Create3::GetOdometryResults::Pipeline::getVelocity() {
  return  ::kipr::create3::Twist::Pipeline(_typeless.getPointerField(1));
}
#endif  // !CAPNP_LITE
inline void Create3::GetOdometryResults::Builder::setVelocity( ::kipr::create3::Twist::Reader value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::set(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), value);
}
inline  ::kipr::create3::Twist::Builder Create3::GetOdometryResults::Builder::initVelocity() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::init(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}
inline void Create3::GetOdometryResults::Builder::adoptVelocity(
    ::capnp::Orphan< ::kipr::create3::Twist>&& value) {
  ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::adopt(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS), kj::mv(value));
}
inline ::capnp::Orphan< ::kipr::create3::Twist> Create3::GetOdometryResults::Builder::disownVelocity() {
  return ::capnp::_::PointerHelpers< ::kipr::create3::Twist>::disown(_builder.getPointerField(
      ::capnp::bounded<1>() * ::capnp::POINTERS));
}

}  // namespace
}  // namespace

CAPNP_END_HEADER

